for (i in 1:RunTimes) {
TrainIndex = sample(nrow(Default), nrow(Default)/2)
logistic.fit = glm(default ~ income + balance,
data = Default,
subset = TrainIndex,
family = "binomial")
logistic.prob = predict(logistic.fit,
newdata = Default[-TrainIndex, ],
type = "response")
logistic.pred = rep('No', times = nrow(Default[-TrainIndex, ]))
logistic.pred[logistic.prob > 0.5] = 'Yes'
# table('Logistic Prediction'= logistic.pred, 'Observation' = Default[-TrainIndex, 'default'])
logistic.error.rate[i,] = mean(logistic.pred != Default[-TrainIndex, 'default'])
}
row.names(logistic.error.rate) = logistic.error.rate$`Run Number`
logistic.error.rate
RunTimes = 3
logistic.error.rate = data.frame(matrix(0,
nrow = RunTimes,
ncol = 1,
dimnames = list(NULL, 'Error Rate')))
for (i in 1:RunTimes) {
TrainIndex = sample(nrow(Default), nrow(Default)/2)
logistic.fit = glm(default ~ income + balance,
data = Default,
subset = TrainIndex,
family = "binomial")
logistic.prob = predict(logistic.fit,
newdata = Default[-TrainIndex, ],
type = "response")
logistic.pred = rep('No', times = nrow(Default[-TrainIndex, ]))
logistic.pred[logistic.prob > 0.5] = 'Yes'
# table('Logistic Prediction'= logistic.pred, 'Observation' = Default[-TrainIndex, 'default'])
logistic.error.rate[i,] = mean(logistic.pred != Default[-TrainIndex, 'default'])
}
row.names(logistic.error.rate) = logistic.error.rate$`Run Number`
logistic.error.rate
RunTimes = 3
logistic.error.rate = data.frame(matrix(0,
nrow = RunTimes,
ncol = 1,
dimnames = list(NULL, 'Error Rate')))
for (i in 1:RunTimes) {
TrainIndex = sample(nrow(Default), nrow(Default)/2)
logistic.fit = glm(default ~ income + balance,
data = Default,
subset = TrainIndex,
family = "binomial")
logistic.prob = predict(logistic.fit,
newdata = Default[-TrainIndex, ],
type = "response")
logistic.pred = rep('No', times = nrow(Default[-TrainIndex, ]))
logistic.pred[logistic.prob > 0.5] = 'Yes'
# table('Logistic Prediction'= logistic.pred, 'Observation' = Default[-TrainIndex, 'default'])
logistic.error.rate[i,] = mean(logistic.pred != Default[-TrainIndex, 'default'])
}
row.names(logistic.error.rate) = logistic.error.rate$`Run Number`
logistic.error.rate
RunTimes = 3
logistic.error.rate = data.frame(matrix(0,
nrow = RunTimes,
ncol = 1,
dimnames = list(NULL, 'Error Rate')))
for (i in 1:RunTimes) {
TrainIndex = sample(nrow(Default), nrow(Default)/2)
logistic.fit = glm(default ~ income + balance,
data = Default,
subset = TrainIndex,
family = "binomial")
logistic.prob = predict(logistic.fit,
newdata = Default[-TrainIndex, ],
type = "response")
logistic.pred = rep('No', times = nrow(Default[-TrainIndex, ]))
logistic.pred[logistic.prob > 0.5] = 'Yes'
# table('Logistic Prediction'= logistic.pred, 'Observation' = Default[-TrainIndex, 'default'])
logistic.error.rate[i,] = mean(logistic.pred != Default[-TrainIndex, 'default'])
}
row.names(logistic.error.rate) = logistic.error.rate$`Run Number`
logistic.error.rate
# Part b - validation set approach (single run)
ValidationSetLogistic <- function(RunTimes) {
logistic.error.rate = data.frame(matrix(0,
nrow = RunTimes,
ncol = 1,
dimnames = list(NULL, 'Error Rate')))
for (i in 1:RunTimes) {
TrainIndex = sample(nrow(Default), nrow(Default)/2)
logistic.fit = glm(default ~ income + balance,
data = Default,
subset = TrainIndex,
family = "binomial")
logistic.prob = predict(logistic.fit,
newdata = Default[-TrainIndex, ],
type = "response")
logistic.pred = rep('No', times = nrow(Default[-TrainIndex, ]))
logistic.pred[logistic.prob > 0.5] = 'Yes'
# table('Logistic Prediction'= logistic.pred, 'Observation' = Default[-TrainIndex, 'default'])
logistic.error.rate[i,] = mean(logistic.pred != Default[-TrainIndex, 'default'])
}
row.names(logistic.error.rate) = logistic.error.rate$`Run Number`
logistic.error.rate
}
ValidationSetLogistic(3)
ValidationSetLogistic(3)
ValidationSetLogistic(3)
ValidationSetLogistic(7)
ValidationSetLogistic()
# Part b - validation set approach (single run)
ValidationSetLogistic <- function(RunTimes = 1) {
logistic.error.rate = data.frame(matrix(0,
nrow = RunTimes,
ncol = 1,
dimnames = list(NULL, 'Error Rate')))
for (i in 1:RunTimes) {
TrainIndex = sample(nrow(Default), nrow(Default)/2)
logistic.fit = glm(default ~ income + balance,
data = Default,
subset = TrainIndex,
family = "binomial")
logistic.prob = predict(logistic.fit,
newdata = Default[-TrainIndex, ],
type = "response")
logistic.pred = rep('No', times = nrow(Default[-TrainIndex, ]))
logistic.pred[logistic.prob > 0.5] = 'Yes'
# table('Logistic Prediction'= logistic.pred, 'Observation' = Default[-TrainIndex, 'default'])
logistic.error.rate[i,] = mean(logistic.pred != Default[-TrainIndex, 'default'])
}
row.names(logistic.error.rate) = logistic.error.rate$`Run Number`
return(logistic.error.rate)
}
ValidationSetLogistic()
ValidationSetLogistic(5)
mean(logistic.error.rate)
mean(logistic.error.rate[, 1]
return(mean(logistic.error.rate[, 1]))
mean(logistic.error.rate[, 1])
ValidationSetLogistic(5)
# Part b - validation set approach (single run)
ValidationSetLogistic <- function(RunTimes = 1) {
logistic.error.rate = data.frame(matrix(0,
nrow = RunTimes,
ncol = 1,
dimnames = list(NULL, 'Error Rate')))
for (i in 1:RunTimes) {
TrainIndex = sample(nrow(Default), nrow(Default)/2)
logistic.fit = glm(default ~ income + balance,
data = Default,
subset = TrainIndex,
family = "binomial")
logistic.prob = predict(logistic.fit,
newdata = Default[-TrainIndex, ],
type = "response")
logistic.pred = rep('No', times = nrow(Default[-TrainIndex, ]))
logistic.pred[logistic.prob > 0.5] = 'Yes'
# table('Logistic Prediction'= logistic.pred, 'Observation' = Default[-TrainIndex, 'default'])
logistic.error.rate[i,] = mean(logistic.pred != Default[-TrainIndex, 'default'])
}
row.names(logistic.error.rate) = logistic.error.rate$`Run Number`
return(mean(logistic.error.rate[, 1]))
}
ValidationSetLogistic(5)
ValidationSetLogistic(5)
ValidationSetLogistic(5)
ValidationSetLogistic(5)
ValidationSetLogistic(50)
ValidationSetLogistic(50)
ValidationSetLogistic(50)
ValidationSetLogistic(50)
ValidationSetLogistic(50)
ValidationSetLogistic(3)
ValidationSetLogistic(3)
ValidationSetLogistic(300)
ValidationSetLogistic(3)
##### End ####
##@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
rm(list = ls()) ; dev.off() ; plot.new()
plot.new()
# Part b - Coefficients SE using bootstrap approach
boot.fn = function(data, index)
# Part b - Coefficients SE using bootstrap approach
boot.fn = function(data, index) {
return(coef(glm(default ~ income + balance,
data = Default,
subset = index,
family = "binomial")))
}
lapply(c("MASS", "tidyverse", "ISLR", "car", "ggcorrplot", "psych", "class", "boot"),
require, character.only = T) # to load multiple packages at once
######### Ch 5 - Ex 6 - Logistic on Default Data (SE of Coefficients) ########
data("Default")
# Part b - Coefficients SE using bootstrap approach
boot.fn = function(InputData, index) {
return(coef(glm(default ~ income + balance,
data = InputData,
subset = index,
family = "binomial")))
}
Default
boot.fn(Default, 1:392)
lapply(c("MASS", "tidyverse", "ISLR", "car", "ggcorrplot", "psych", "class", "boot"),
require, character.only = T) # to load multiple packages at once
######### Ch 5 - Ex 6 - Logistic on Default Data (SE of Coefficients) ########
data("Default")
# Part b - Coefficients SE using bootstrap approach
boot.fn = function(InputData, index) {
return(coef(glm(default ~ income + balance,
data = InputData,
subset = index,
family = "binomial")))
}
boot.fn(Default, 1:392)
boot.fn(Auto, sample(392, 392, replace = T))
boot.fn(Default, 1:392)
boot.fn(Default, 1:392)
boot.fn(Default, 1:392)
sample(392, 392, replace = T)
boot.fn(Default, sample(392, 392, replace = T))
boot.fn(Default, sample(392, 392, replace = T))
boot.fn(Default, sample(392, 392, replace = T))
#### OPTIONS ####
options(digits = 4)                   # to specify number of significant decimal digits when printing output
options(show.signif.stars=FALSE)      # removes the stars from regression output showing significance
options(scipen=-1)                    # turn-off scientific notation (positive value removes it, negative value does it - don't go below -5 for ggplot messes up)
options(max.print = 999999)           # to extend the limit of output columns in console
boot.fn(Default, sample(392, 392, replace = T))
options(scipen = 9)
boot.fn(Default, sample(392, 392, replace = T))
boot.fn(Default, sample(392, 392, replace = T))
boot.fn(Default, sample(392, 392, replace = T))
boot(Default, boot.fn, R = 100)
# Part c - use boot function to run the boot.fn function defined before for a certain number of times and find SE of coefficients
boot(Default, boot.fn, R = 1000)
# Part c - use boot function to run the boot.fn function defined before for a certain number of times and find SE of coefficients
boot(Default, boot.fn, R = 300)
glm(default ~ income + balance,
data = Default,
family = "binomial") %>%
summary() %>%
coef()
# Part c - use boot function to run the boot.fn function defined before for a certain number of times and find SE of coefficients
boot(Default, boot.fn, R = 4)
# Part c - use boot function to run the boot.fn function defined before for a certain number of times and find SE of coefficients
boot(Default, boot.fn, R = 4)
glm(default ~ income + balance,
data = Default,
family = "binomial") %>%
summary() %>%
coef()
# Part c - use boot function to run the boot.fn function defined before for a certain number of times and find SE of coefficients
boot(Default, boot.fn, R = 40)
# Part c - use boot function to run the boot.fn function defined before for a certain number of times and find SE of coefficients
boot(Default, boot.fn, R = 40)
######### Ch 5 - Ex 7 - Logistic on Weekly Data (SE of Coefficients) ########
data("Weekly")
glimpse(Weekly)
glm(Direction ~ Lag1 + Lag2,
data = Weekly,
family = "binomial") # %>%
glm(Direction ~ Lag1 + Lag2,
data = Weekly,
family = "binomial") # %>%
glm(Direction ~ Lag1 + Lag2,
data = Weekly,
family = "binomial") %>%
summary() %>%
coef()
logistic.fit <- glm(Direction ~ Lag1 + Lag2,
data = Weekly,
family = "binomial")
coef(logistic.fit)
logistic.prob = predict(logistic.fit,
#newdata = Default[-TrainIndex, ],  # this is our test set using the opposite of training index
type = "response")
logistic.prob
nrow(Weekly)
contrasts(Weekly$Direction)
logistic.pred = rep('Down', times = nrow(Weekly))
logistic.pred
logistic.pred[logistic.prob > 0.5] = 'Up'
logistic.pred
table('Logistic Prediction'= logistic.pred, 'Observation' = Weekly$Direction)
Weekly$Direction
logistic.pred
table('Logistic Prediction'= logistic.pred, 'Observation' = Weekly$Direction)
(logistic.error.rate = mean(logistic.pred != Weekly$Direction))
######### Ch 5 - Ex 7 - Logistic on Weekly Data (SE of Coefficients) ########
attach("Weekly")
logistic.fit <- glm(Direction ~ Lag1 + Lag2,
data = Weekly,
family = "binomial")
coef(logistic.fit)
nrow(Weekly)
nrow(Weekly)-1
sample(nrow(Weekly), nrow(Weekly)-1)
nrow(sample(nrow(Weekly), nrow(Weekly)-1))
length(sample(nrow(Weekly), nrow(Weekly)-1))
length(sample(10, 9))
sample(10, 9)
sample(10, 9)
sample(10, 9)
nrow(Weekly)
# Part b - fit logistic and predict Direction from Lag1 and Lag2 (using all but 1 observation)
TrainIndex = sample(nrow(Weekly), nrow(Weekly)-1) # generate random numbers between 1 and 1089 for a total of 1088
logistic.fit <- glm(Direction ~ Lag1 + Lag2,
data = Weekly,
subset = TrainIndex,
family = "binomial")
summary(logistic.fit)
# Part b - fit logistic and predict Direction from Lag1 and Lag2 (using all but 1 observation)
TrainIndex = sample(nrow(Weekly), nrow(Weekly)-1) # generate random numbers between 1 and 1089 for a total of 1088
logistic.fit <- glm(Direction ~ Lag1 + Lag2,
data = Weekly,
subset = TrainIndex,
family = "binomial")
summary(logistic.fit)
# Part b - fit logistic and predict Direction from Lag1 and Lag2 (using all but 1 observation)
set.seed(1)
TrainIndex = sample(nrow(Weekly), nrow(Weekly)-1) # generate random numbers between 1 and 1089 for a total of 1088
logistic.fit <- glm(Direction ~ Lag1 + Lag2,
data = Weekly,
subset = TrainIndex,
family = "binomial")
summary(logistic.fit)
# Part b - fit logistic and predict Direction from Lag1 and Lag2 (using all but 1 observation)
set.seed(1)
TrainIndex = sample(nrow(Weekly), nrow(Weekly)-1) # generate random numbers between 1 and 1089 for a total of 1088
logistic.fit <- glm(Direction ~ Lag1 + Lag2,
data = Weekly,
subset = TrainIndex,
family = "binomial")
summary(logistic.fit)
coef(logistic.fit)
logistic.fit1 <- glm(Direction ~ Lag1 + Lag2,
data = Weekly,
family = "binomial")
coef(logistic.fit1)
logistic.prob = predict(logistic.fit1,
type = "response")
contrasts(Weekly$Direction)
logistic.pred = rep('Down', times = nrow(Weekly))
logistic.pred[logistic.prob > 0.5] = 'Up'
table('Logistic Prediction'= logistic.pred, 'Observation' = Weekly$Direction)
(logistic.error.rate = mean(logistic.pred != Weekly$Direction))
# Part b - fit logistic and predict Direction from Lag1 and Lag2 (using all but 1 observation)
set.seed(1)
TrainIndex = sample(nrow(Weekly), nrow(Weekly)-1) # generate random numbers between 1 and 1089 for a total of 1088
logistic.fit2 <- glm(Direction ~ Lag1 + Lag2,
data = Weekly,
subset = TrainIndex,
family = "binomial")
summary(logistic.fit2)
data = Weekly[-1, ]
Weekly[-1, ]
head(Weekly[-1, ])
head(Weekly)
head(Weekly[-1, ])
########### Data Types - Data Frame ###########
# Can combine vectors of the same length
vNumeric   <- c(1, 2, 3, 14)
vCharacter <- c("a", "b", "c", "a")
vLogical   <- c(T, F, T, F)
dfa <- cbind(vNumeric, vCharacter, vLogical)  # cbind is used to bind vectors by columns (to do it by rows, we use rbind)
dfa
df                                            # Makes a dataframe with three different data types
df                                            # Makes a dataframe with three different data types
df <- as.data.frame(cbind(vNumeric,           # careful! the size of vectors must be equal or strange things can happen this way
vCharacter,
vLogical))
df                                            # Makes a dataframe with three different data types
df[-1, ]
# Part b - fit logistic and predict Direction from Lag1 and Lag2 (using all but 1 observation)
set.seed(1)
logistic.fit2 <- glm(Direction ~ Lag1 + Lag2,
data = Weekly[-1, ],
family = "binomial")
summary(logistic.fit2)
Weekly[1, ]
# Part c - predict direction of the first observation (testing)
logistic.prob = predict(logistic.fit2,
newdata = Weekly[1, ],
type = "response")
logistic.prob
# Part c - predict direction of the first observation (testing)
logistic.prob = predict(logistic.fit2,
newdata = Weekly[1, ],
type = "response") > 0.5
# Part c - predict direction of the first observation (testing)
predict(logistic.fit2,
newdata = Weekly[1, ],
type = "response") > 0.5
# Part c - predict direction of the first observation (testing)
predict(logistic.fit2,
newdata = Weekly[1, ],
type = "response") > 0.5
predict.glm(logistic.fit2,
newdata = Weekly[1, ],
type = "response") > 0.5
# Part c - predict direction of the first observation (testing)
logistic.prob = predict(logistic.fit2,
newdata = Weekly[1, ],
type = "response") > 0.5
if (logistic.prob > 0.5) {
print("predicted Direction is Up for 1st observation")
}
print("predicted Direction is Up for 1st observation ; incorrect prediction")
print("predicted Direction is Up for 1st observation \nIncorrect Prediction")
paste("predicted Direction is Up for 1st observation \n Incorrect Prediction")
paste("predicted Direction is Up for 1st observation", "\n", "Incorrect Prediction")
paste("predicted Direction is Up for 1st observation", "\n", "Incorrect Prediction", "\n")
paste("predicted Direction is Up for 1st observation", "\n", "Incorrect Prediction", "\n")
test <- paste("predicted Direction is Up for 1st observation", "\n", "Incorrect Prediction", "\n")
cat(test)
# cat or message is a function to output/print a concatenation without converting/showing in character like paste does
cat("I am number",  25)
cat("Predicted Direction is Up for 1st observation", "\n", "Incorrect Prediction", "\n")
cat("Predicted Direction is Down for 1st observation", "\n", "Correct Prediction")
nrow(Weekly)
1:nrow(Weekly)
i=3
Weekly[i, ]
Weekly[-i, ]
df
df[-i,]
logistic.fit.i <- glm(Direction ~ Lag1 + Lag2,
data = Weekly[-i, ],
family = "binomial")
logistic.fit.i
logistic.prob.i = predict(logistic.fit.i,
newdata = Weekly[i, ],
type = "response")
logistic.prob.i
# Part d -
i=15
logistic.fit.i <- glm(Direction ~ Lag1 + Lag2,
data = Weekly[-i, ],
family = "binomial")
logistic.prob.i = predict(logistic.fit.i,
newdata = Weekly[i, ],
type = "response")
logistic.prob.i
rep(0,5)
LOOCV.error = rep(0, nrow(Weekly))
LOOCV.error
logistic.prob.i
if (logistic.prob.i > 0.5) {
LOOCV.error[i] = 1
}
LOOCV.error
for (index in 1:nrow(Weekly)) {
logistic.fit.i <- glm(Direction ~ Lag1 + Lag2,
data = Weekly[-i, ],
family = "binomial")
logistic.prob.i = predict(logistic.fit.i,
newdata = Weekly[i, ],
type = "response")
if (logistic.prob.i > 0.5) {
LOOCV.error[i] = 1
}
}
LOOCV.error
for (index in 1:nrow(Weekly)) {
logistic.fit.i <- glm(Direction ~ Lag1 + Lag2,
data = Weekly[-index, ],
family = "binomial")
logistic.prob.i = predict(logistic.fit.i,
newdata = Weekly[index, ],
type = "response")
if (logistic.prob.i > 0.5) {
LOOCV.error[index] = 1
}
}
LOOCV.error
Weekly
LOOCV.error
Weekly$Direction[1089,]
nrow(Weekly)
Weekly$Direction[1089]
Weekly$Direction[1089] == LOOCV.error[1089]
index
Weekly$Direction[index]
Predicted.Direction
if (logistic.prob.i > 0.5) {Predicted.Direction = "Up"}
Predicted.Direction
if (Predicted.Direction != Weekly$Direction[index]) {LOOCV.error = 1}
for (index in 1:nrow(Weekly)) {
logistic.fit.i <- glm(Direction ~ Lag1 + Lag2,
data = Weekly[-index, ],
family = "binomial")
logistic.prob.i = predict(logistic.fit.i,
newdata = Weekly[index, ],
type = "response")
if (logistic.prob.i > 0.5) {Predicted.Direction = "Up"}
else {Predicted.Direction = "Down"}
if (Predicted.Direction != Weekly$Direction[index]) {LOOCV.error = 1}
}
LOOCV.error
# Part d -
LOOCV.error = rep(0, nrow(Weekly))
for (index in 1:nrow(Weekly)) {
logistic.fit.i <- glm(Direction ~ Lag1 + Lag2,
data = Weekly[-index, ],
family = "binomial")
logistic.prob.i = predict(logistic.fit.i,
newdata = Weekly[index, ],
type = "response")
if (logistic.prob.i > 0.5) {Predicted.Direction = "Up"}
else {Predicted.Direction = "Down"}
if (Predicted.Direction != Weekly$Direction[index]) {LOOCV.error[index] = 1}
}
LOOCV.error
# Part e - LOOOCV estimate for test error
mean(LOOCV.error)
